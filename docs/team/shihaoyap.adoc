= Yap Shi Hao - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets

== PROJECT: AddMin+ - All in one administration desktop application

---

== Overview on Project

AddMin+ is student developed application for a school project (CS2103T). The project requires us to enhance a basic command line
interface desktop application which is the `AddressBook - Level 3` that was developed by the se-edu team. The
`AddressBook - Level 3` is a desktop address book application used for teaching Software Engineering principles.

== About AddMin+

The AddMin+ Team is made up of 5 Computer science students from AY1920S1-CS2103T-T11-3. The team decided to morph and enhance
the capabilities of the original application into an All in one administration desktop application. The application is specially
designed for the use of any events management start-up company with limited manpower and resources.

AddMin+ is specially designed to ease the workload of the admin staffs in these companies and allow him/her to
effectively handle the administrative tasks of the company by providing the following functions: event creation and
deletion, editing of event details after creation, manual and automatic manpower allocation for events and providing an
overview of all the data via statistics while keeping track of the companies schedule to ensure that no event is missed!

This is what AddMin+ looks like:

._The graphical user interface for *AddMin+*_
image::AddMin+Ui.png[]


My role was to design and write codes for the entire `Schedule` section of the project. The following sections will illustrate
the enhancements in more detail, as well as provide relevant documentation that i have added to the user and developer guides
in relation to those enhancements.

Note the following symbols and formatting used in this documents:
[TIP]
*LightBulbs* indicate a _Tip_, something that is helpful to the reader

[NOTE]
*'i' Icon* indicate a _Note_ that supplements useful information

Text in a link:[`blue font and grey`] background indicates a _hyperlink_

Text with a `grey background` indicates _Code Logic_ such as class objects, OOP definitions or user-input.


== Summary of contributions
This section will show a summary of all the features, enhancements, documentations, and other useful contributions that i have
contributed to the team project.

* *Major enhancement*: added and implemented the entire *Schedule* section of the project which includes major GUI implementations
and 3 schedule related features.
** What it does: The *Schedule* section was implemented to allow users to have an easier way to view and identify
the events that are going on a specific date, period. Thus, the `display_schedule_date` and `display_schedule` feature was implemented.
The enhancement was also done to improve the user experience, by providing a clean graphical representation of the user's specified
schedule, which could be seen from the *Schedule* tab and the window generated by the `generate_schedule` feature.
** Justification: This feature improves the product significantly because it allows users to have a convenient way to view their upcoming
event schedule and keep track of all the event dates. This feature will greatly increase the user experience of the application.
** Highlights: This enhancement requires the event objects extensively. The implementation of the *Schedule* features required an in-depth
analysis of the application's storage architecture and modeling. The implementation of *Schedule* was also challenging as it required the
implementation of an additional `DistinctDate` object for the `generate_schedule` feature.

* *Minor enhancement*: minor Graphic User Interface changes to improve the user experience of the application.

* *Code contributed*: [https://github.com[Functional code]] [https://github.com[Test code]] _{give links to collated code files}_

* *Other contributions*:

** Project management:
*** Helped morphed the Events class and storage units into AddMin+ (Pull requests
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/76[#76], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/79[#79],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/86[#86], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/87[#87])
*** In charged of Add and Edit event commands for AddMin+ (Pull requests
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/76[#76], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/79[#79])
*** Assisted in refactoring process for person class to employee class and well as fixed test cases and checkstyle errors.
(Pull requests https://github.com/AY1920S1-CS2103T-T11-3/main/pull/92[#92]
*** In charged of keep track of deadlines, submissions and issue trackers.
** Enhancements to existing features:
*** Updated the GUI card display and other GUI enhancements (Pull requests https://github.com/AY1920S1-CS2103T-T11-3/main/pull/143[#143])
*** Wrote additional tests for existing features (Pull requests https://github.com/AY1920S1-CS2103T-T11-3/main/pull/139[#139])
** Documentation:
*** Did cosmetic tweaks to existing contents of the User Guide: (Pull requests https://github.com/AY1920S1-CS2103T-T11-3/main/pull/127[#127],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/53[#53], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/54[#54],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/58[#58], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/60[#60],
 https://github.com/AY1920S1-CS2103T-T11-3/main/pull/143[#143])
** Community:
*** PRs reviewed (with non-trivial review comments): (Pull requests https://github.com/AY1920S1-CS2103T-T11-3/main/pull/66[#66],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/76[#76], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/78[#78],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/85[#85], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/83[#83],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/92[#92], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/99[#99],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/103[#103], https://github.com/AY1920S1-CS2103T-T11-3/main/pull/124[#124],
https://github.com/AY1920S1-CS2103T-T11-3/main/pull/137[#137])

== Contributions to the User Guide
|===
|_The original AddressBook User Guide have been updated to document the new capabilities of AddMin+ functionality.
The following are excerpts from the AddMin+ User Guide, which will showcase the sections that i have contributed to. They
will showcase my ability to write documentation for end-users._
|===

=== Schedule
Welcome to Schedule! Wondering how to display and see what events you have on a specific Date or Month, or do you
want to have an overview of all the dates where you have an event? Then you are at the right place!

To get things started, all Schedule-related commands occurs in the Schedule Tab as seen from the figure below! You could either
click on the Schedule Tab or just simply type in any Schedule-related commands and AddMin+ will bring you there.

._User Interface (UI) of the Schedule Feature_
image::ScheduleUiDetailed.png[]

==== Display Schedule for a specific date
Lets say you want to check if you have any events on a specific date. Instead of looking through the list of events you have, you
could simply use the `display_schedule_date` command to do it!

Format: `display_schedule_date on/dd/MM/yyyy`

Examples:
`display_schedule_date on/02/12/2019`

****
* on/ represents the date in dd/MM/yyyy that the user wants to display
****


**To display schedule for a specific date (20/11/2019):**

**Step 1**.  Either type `display_schedule_date on/20/11/2019` into the command box or click on the specific date from the date picker.

image::ScheduleUiStep1.png[]

**Step 2**.  The result box will display a message which inform you how many events are being listed. In this case the message displayed
is "1 events listed!"

image::ScheduleUiStep2.png[]

**Step 3**.  In the event list you will be able to see all the events that are on the specified date. In this case the only event that is on
20/11/2019 is "Talk by DEF Company".

image::ScheduleUiStep3.png[]

[TIP]
The event list will be empty and not display anything if there is no event on the specified date.

==== Display Schedule for a specific Month and Year
Now if you would want to see all the events you have on a specific month and year. Instead of looking through the list of events you have, you
could simply use the `display_schedule` command to do it!

Format: `display_schedule for/MM/yyyy`

****
* for/ represents the month and year in MM/yyyy that the user wants to display
****

**To display schedule for a specific Month and Year (11/2019):**

**Step 1**.  Either type `display_schedule for/11/2019` into the command box or click on the month year picker buttons to
navigate to the specific month and year.

image::ScheduleUiMonthStep1.png[]

**Step 2**.  The result box will display a message which inform you how many events are being listed. In this case the message displayed
is "2 events listed!"

image::ScheduleUiMonthStep2.png[]

**Step 3**.  In the event list you will be able to see all the events that are on the specified month, year. In this case there is 2 event
that is on 11/2019 which is "Talk by DEF Company" and "Birthday Party".

image::ScheduleUiMonthStep3.png[]

[TIP]
The event list will be empty and not display anything if there is no event on the specified month, year.

==== Generate Entire Schedule
Want to have an overview of all the dates that has an event? Use the `generate_schedule` command to do so. The `generate_schedule` command
looks through the entire list of events and generates a new list of all the dates which has an event and also display all the events that happens
on that date.

Format: `generate_schedule`

[TIP]
The `generate_schedule` command opens a new window to display the new list of information.

**To display the entire schedule:**

**Step 1**.  Either type `generate_schedule` into the command box or click on the generate schedule button to display the entire schedule.

image::ScheduleUiGenerateStep1.png[]

**Step 2**.  The result box will display the message "Schedule Generated".

image::ScheduleUiGenerateStep2.png[]

**Step 3**.  A new window will open, displaying all the dates and events that is happening on those specific dates.

image::ScheduleUiGenerateStep3.png[]

[TIP]
The generated list will be empty and not display anything if there is no event in the current event list.

include::../UserGuide.adoc[tag=Schedule]

== Contributions to the Developer Guide
|===
|_Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical
documentation and the technical depth of my contributions to the project._
|===

=== Generate Schedule feature
==== Proposed Implementation

The Generate Schedule Feature is implemented to allow users to have an overview of view all dates that has an event and the
specific events for those dates listed. The feature is facilitated by a `DistinctDatesProcessor` and requires the use of a
new Object - `DistinctDate`, as well as an internal ObservableList - `distinctDatesList` found in the `ModelManager`.

It processes the entire list of Events in the `EventList` when the command is called. The `DistinctDateProcessor` will then
process through these events to create specific `DistinctDate` Objects which stores a list of events which occurs on the date
they are representing. These DistinctDate Objects are then used to be displayed on the GUI.

Additionally, The DistinctDateProcessor contains the following operations:

* `generateDistinctDateList(Model model)` -- Returns a list of `DistinctDate` Objects. This operation utilises the generateDateList() and generateListOfEventForDate() operations.
* `generateListOfEventForDate(LocalDate date, Model model)` -- Takes in a `LocalDate` object, and processes through the entire list of events, to find all events on that specific date, and return them as a list.
* `generateDateList(Model model)` -- Takes in the entire list of events, identify all the dates that has at least one event and returns it as a list.

The following class diagrams shows how the `DistinctDate` class and utility `DistinctDateProcessor` class is implemented:

._Class Diagram for DistinctDate_
image::DistinctDateClassDiagram.png[align="center", width = "300"]
._Class Diagram for DistinctDateProcessor_
image::DistinctDateProcessorClassDiagram.png[align="center", width = "300"]

Given below is an example usage scenario and how the display schedule mechanism behaves at each step.

._Program flow of the Generate Schedule Feature_
image::GenerateScheduleFlowChart.png[align="center", width = "300"]

**Step 1**. The user launches the application for the first time.

**Step 2**. The `distinctDatesList` will be initialized based on the initial event book state.

**Step 3**. The user executes `add_ev n/Free Coffee ...` to add a new event into the Eventlist.
The distinctDatesList will not be updated, and will not contain the new event that is added.
[NOTE]
Any command that alters the eventBook will not change the distinctDatesList. The distinctDatesList will continue to store the
original list until the User requires it by calling the "generate_schedule" command. Where the distinctDateList will be generated
again using the current EventList


**Step 4**. The user executes `generate_schedule` to see all the dates and the respective events on those dates.

**Step 5**. The distinctDateList will be generated again based on the current list of events in the EventList and is displayed on a separate window.

**Step 6**. The user now decides to close the app, the current state of the EventBook and EmployeeBook will be stored,
however the DistinctDateList would not.

[NOTE]
Note that the Display Schedule Feature does not load and store the DistinctDate Objects. It processes and generates the list when
it is called upon or when the application starts.

**Step 5**. Done.

The following sequence diagram shows how the `generate_schedule` operation works:

._Sequence Diagram for generate_schedule Command_
image::GenerateScheduleSequenceDiagram.png[]

NOTE: The lifeline for `GenerateScheduleCommand` ends at the destroy marker (X).

==== Design Considerations

[width="100%", options="header" cols="3, 4, 4"]
|========================================================================================
|Feature      |Alternative 1 | Alternative 2
|Data Structure to support Generate Schedule Command
|Generates and Processes the DistinctDate Object upon `generate_schedule` command. (Current choice)

*Pros*: Easy to implement and requires less Storage Capacity and storage infrastructure to support the entire feature.

*Cons*: May have performance issues in terms of speed and time Complexity. The program will have to iterate through the entire list of events and create
the corresponding `DistinctDate` objects, whenever `generate_schedule` command is called.

**Decision: Alternative 1
** Alternative 1 makes more logical sense and will be more efficient as compared to Alternative 2. Alternative 1 requires less intermediate processing and storage units to support the feature.
Processing is only done when it is needed. Looking at the use case of the `generate_schedule` command, it is likely to be used when the users have finalise all the events and details before generating
the schedule.

|Creates and Stores the DistinctDate object whenever a new event is added.

*Pros*: Do not have to create a new list of DistinctDate object every time it is called.

*Cons*: May have performance issues in terms of storage and processing needed, requires new storage unit to store a new entity which is not as important
and frequently used. This implementation can cause speed and time complexity issues as well, whenever edits are made to the existing eventList - add_ev, delete_ev etc
the program is required to process through all DistinctDate Object to make the necessary changes. If the user does not even want to call the `generate_schedule` command
after the changes, then this process is actually unnecessary.

| UI Decisions for Generate Schedule Command
| Display Directly on the Schedule Tab, update the list when `generate_schedule` command is called

*Pros*: Users are able to view the generated schedule directly from the application's schedule tab, without the need of another window.

*Cons*: May cause confusion, as the list being displayed might be outdated, if user forgets to call the `generate_schedule` command after altering the events.

| Display on a separate window, generates and display the list on the new window when `generate_schedule` command is called. (Current choice)

*Pros*: Allows for better user experience, since the generated list is only displayed when the user needs it. Ensures that the list being
displayed is always updated as of when the user needs it, since the window is only produced when `generate_schedule` command is called.

*Cons*: Harder to implement, requires additional JavaFx windows and implementations. Will require additional windows being opened.

**Decision: Alternative 2
** Alternative 2 is a cleaner and more user friendly approach compared to Alternative 1. Alternative 2 helps to prevent the Schedule Tab from being filled with too many list and information.
Alternative 2 also helps prevent user confusion, as the list that is displayed is always updated as of when it is called upon.
|========================================================================================

include::../DeveloperGuide.adoc[tag=undoredo]

include::../DeveloperGuide.adoc[tag=dataencryption]


== PROJECT: PowerPointLabs

---

_{Optionally, you may include other projects in your portfolio.}_
